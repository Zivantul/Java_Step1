import com.sun.prism.shader.Solid_TextureRGB_AlphaTest_Loader;
import com.sun.scenario.effect.impl.sw.sse.SSEBlend_SRC_OUTPeer;

/*
1. Полностью разобраться с кодом, попробовать переписать с нуля, стараясь не подглядывать в методичку;

2. Переделать проверку победы, чтобы она не была реализована просто набором условий, например, с использованием циклов.

3. * Попробовать переписать логику проверки победы, чтобы она работала для поля 5х5 и количества фишек 4.
    Очень желательно не делать это просто набором условий для каждой из возможных ситуаций;

4. *** Доработать искусственный интеллект, чтобы он мог блокировать ходы игрока
 */

/**
 * каюсь, немного не допилил AI - не хватило времени до сдачи, чтобы нормаль протестить и отработать исключения
 * буду биться дальше, пока сдаю то, что есть
 */


import java.util.Random;
import java.util.Scanner;

public class Main {

    static int SIZE_x;
    static int SIZE_y;
    static int SIZE_game;
    static int SIZE_win;
    static int SIZE_gap;

    static int x_AI=0;
    static int y_AI=0;
    static boolean in_AI;

    static char [][] field;
    static Scanner scanner = new Scanner(System.in);
    static Random random = new Random();

    static char PLAYER_DOT = 'X';
    static char AI_DOT = 'O';
    static char EMPTY_DOT = '_';

    /**
     * метод задает размер поля и определяет условие выигрыша (сколько знаков должно совпасть для выигрыша)
     */
    static void setSize(){
        System.out.println("Задайте размер игрового поля:");
        SIZE_game = scanner.nextInt();
        SIZE_x = SIZE_game;
        SIZE_y = SIZE_game;
        field = new char[SIZE_x][SIZE_y];

        System.out.println("Задайте количество знаков подряд для определения выигрыша:");
        SIZE_win = scanner.nextInt();
        SIZE_gap = SIZE_game-SIZE_win;
    }


    /**
     * метод задает игровое поле
     */
    static void initField(){
        setSize();
        for (int i = 0; i < SIZE_y; i++){
            for (int j = 0; j < SIZE_x; j++){
                field[i][j] = EMPTY_DOT;
            }
        }
    }

    static void printField() {
        for (int i = 0; i < SIZE_y; i++) {
            if (i == 0) {
                System.out.print("    " + (i + 1) + "   ");
            } else {
                System.out.print((i + 1) + "   ");
            }
        }
        System.out.println();

        for (int i = 0; i < SIZE_y; i++) {
            System.out.print((i + 1) + " | " );
            for (int j = 0; j < SIZE_x; j++) {
                System.out.print(field[i][j] + " | ");
            }
            System.out.println();
        }

    }

    static void setSym (int y, int x, char sym){
        field[y][x] = sym;
    }

    static void playerStep () {
        int x;
        int y;
        do {
            System.out.println("Введите координаты X и Y от 1 до " + SIZE_game + ": ");
            x = scanner.nextInt() - 1;
            y = scanner.nextInt() - 1;
        } while (!isCellValid(y, x));
        setSym(y, x, PLAYER_DOT);
    }

    static void aiStep () {
        int x;
        int y;

        if (in_AI){
            x = y_AI;
            y = x_AI;
            setSym(y, x, AI_DOT);
            in_AI=false;
        } else {
            do {
                x = random.nextInt(SIZE_x);
                y = random.nextInt(SIZE_y);
            } while (!isCellValid(y, x));
            setSym(y, x, AI_DOT);
        }
    }

    /** Метод для проверки возможности установки значка в поле
     *
     * @param y - координата по y
     * @param x - координата по х
     * @return - вернте t or f
     */
    static boolean isCellValid (int y, int x){
        if (x < 0 || x >= SIZE_x || y < 0 || y>= SIZE_y) {
            return false;
        }
        return field[y][x] == EMPTY_DOT;
    }


    /**
     * метод определяет победу или ничью
     * @param sym знак для которого проверяем победу
     * @return возвращает 1 если победа игрока, 2 если победа ПК
     *
     */
    static int checkWin (char sym){
        int schet = 0;
        int itog = 0;

        schet = sumHorizont(sym);

        if (schet < SIZE_win) {
            schet = sumVertikal(sym);
        }

        if (schet < SIZE_win) {
            schet = sumDiagonal(sym);
        }

        if (schet == SIZE_win) {
            if (sym == PLAYER_DOT) {
                itog = 1;
            } else if (sym == AI_DOT) {
                itog = 2;
            }
        }

    return itog;
    }



    /**
     * метод считаеn сумму переданных значков по горизонтали
     * @param sym знак? который считаем (Х или О)
     * @return возвращает количество совпавших подряд значков по горизонтали
     */
    static int sumHorizont(char sym) {
        //по горизонтали
        int schet=0;

        for (int i=0; i<SIZE_y; i++){
            schet=0;
            for (int j=0; j<SIZE_x; j++){
                if (field[i][j] == sym) {
                    schet++;
                } else {
                    schet=0;
                }

                if (schet == SIZE_win-1) {
                    x_AI = i;
                    y_AI = j+1;
                    in_AI=true;

                    if (y_AI>SIZE_game-1) {
                        y_AI = j - (SIZE_win-1);
                        if (y_AI<0) {
                            in_AI=false;
                        }
                    }
                }

                if (schet==SIZE_win) {
                    return schet;
                }
            }
        }

        return schet;
    }

    /**
     * метод считаеn сумму переданных значков по вертикали
     * @param sym знак? который считаем (Х или О)
     * @return возвращает количество совпавших подряд значков по вертикали
     */
    static int sumVertikal(char sym) {
        // по вертикали
        int schet = 0;
        for (int i=0; i<SIZE_x; i++){
            schet=0;
            for (int j=0; j<SIZE_y; j++){
                if (field[j][i] == sym) {
                    schet++;
                } else {
                    schet=0;
                }

                if (schet == SIZE_win-1) {
                    y_AI = i;
                    x_AI = j+1;
                    in_AI=true;

                    if (x_AI>SIZE_game-1) {
                        x_AI = i - (SIZE_win-1);
                        if (x_AI<0) {
                            in_AI=false;
                        }
                    }
                }

                if (schet==SIZE_win) {
                    return schet;
                }
            }
        }
        return schet;
    }

    /**
     * метод считаем сумму переданных значков по диагоналям
     * @param sym знак? который считаем (Х или О)
     * @return возвращает количество совпавших подряд значков по диагоналям
     */
    static int sumDiagonal(char sym) {
        // по диагонали
        int schet =0;
        int frst, lst, nxt, k, f;
        int numbPop;

        for (k=0; k<=SIZE_gap; k++) {
            for (f=0; f<=SIZE_gap;f++) {
                if (k!=0 || f!=0){
                    numbPop = SIZE_game-SIZE_gap;
                } else {
                    numbPop = SIZE_game;
                }
                for (frst = 0 + k, lst = SIZE_game - 1 - f; frst < (numbPop+k); frst++, lst--) {
                    if (field[frst][lst] == sym) {
                        schet++;
                    } else {
                        schet = 0;
                    }

                    if (schet == SIZE_win-1) {
                        y_AI = frst++;
                        x_AI = lst--;
                        in_AI=true;

                        if (x_AI<0 || y_AI>SIZE_game-1)  {
                            x_AI = lst - (SIZE_win-1);
                            y_AI= frst + (SIZE_win-1);
                            if (x_AI<0 || y_AI>SIZE_game-1) {
                                in_AI=false;
                            }
                        }
                    }

                    if (schet==SIZE_win) {
                        return schet;
                    }
                }
            }
        }

        if (schet < SIZE_win) {
            schet = 0;
            for (k = 0; k <= SIZE_gap; k++) {
                for (f = 0; f <= SIZE_gap; f++) {
                    if (k != 0 || f != 0) {
                        numbPop = SIZE_game - SIZE_gap;
                    } else {
                        numbPop = SIZE_game;
                    }


                    for (frst = 0; frst < (numbPop); frst++) {
                        if (field[frst + k][frst + f] == sym) {
                            schet++;
                        } else {
                            schet = 0;
                        }


                        if (schet == SIZE_win-1) {
                            y_AI = frst+k+1;
                            x_AI = frst+f+1;
                            in_AI=true;

                            if (x_AI>SIZE_game-1 || y_AI>SIZE_game-1)  {
                                x_AI = (frst+k) - (SIZE_win-1);
                                y_AI= (frst+f) - (SIZE_win-1);
                                if (x_AI>SIZE_game-1 || y_AI>SIZE_game-1) {
                                    in_AI=false;
                                }
                            }
                        }

                        if (schet==SIZE_win) {
                            return schet;
                        }

                    }
                }
            }
        }

        return schet;
    }


    static boolean isFieldFull () {
        for (int i = 0; i < SIZE_y; i++) {
            for (int j = 0; j < SIZE_x; j++) {
                if (field[i][j] == EMPTY_DOT) return false;
            }
        }
        return true;
    }


    public static void main(String[] args) {


        initField();
        printField();

        while (true){
            playerStep();
            System.out.println("Игрок пошел:");
            printField();
            if (checkWin(PLAYER_DOT) == 1) {
                System.out.println("You win! :)");
                break;
            }

            if (isFieldFull()){
                System.out.println("Draw");
                break;
            }

            aiStep();
            System.out.println("AI пошел:");
            printField();
            if (checkWin(AI_DOT)==2) {
                System.out.println("Comp win! :)");
                break;
            }

            if (isFieldFull()){
                System.out.println("Draw");
                break;
            }
        }

    }
}
